<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>ggplotd.aes</title>
        </head><body>
        <h1>ggplotd.aes</h1>
        <!-- Generated by Ddoc from source/ggplotd/aes.d -->
<br><br>
<dl><dt><big><a name="DefaultValues"></a>Tuple!(string, "label", string, "colour", double, "size", double, "angle", double, "alpha", bool, "mask", double, "fill") <u>DefaultValues</u>;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Aes"></a>struct <u>Aes</u>(Specs...);
</big></dt>
<dd><u>Aes</u> is used to store and access data for plotting
<br><br>
<u>Aes</u> is an InputRange, with named Tuples as elements. The names
    refer to certain fields, such as x, y, colour etc. If certain fields
    are not provided then it provides a default value (see DefaultValues).
<br><br>

    The fields commonly used are data fields, such as "x" and "y". Which data
    fields are required depends on the geom* function. By default the named
    Tuple holds the fields:
    <ul>        <li>"label": Text labels (string)</li>
        <li>"colour": Identifier for the colour. In general data points with different colour ids get different colours. This can be almost any type. You can also specify the colour by name or cairo.Color type if you want to specify an exact colour (any type that isNumeric, cairo.Color.RGB(A), or can be converted to string)</li>
        <li>"size": Gives the size of points in pixels (size_t)</li>
        <li>"angle": Angle of printed labels in radians (double)</li>
        <li>"alpha": Alpha value of the drawn object (double)</li>
        <li>"mask": Mask the area outside the axes. Prevents you from drawing outside of the area (bool)</li>
        <li>"fill": Whether to fill the object/holds the alpha value to fill with (double).</li></ul><br><br>
<b>Examples:</b><br>
Basic <u>Aes</u> usage
<pre class="d_code">
<font color=blue>auto</font> aes = <u>Aes</u>!(<font color=blue>double</font>[], <font color=red>"x"</font>, <font color=blue>double</font>[], <font color=red>"y"</font>, string[], <font color=red>"colour"</font>)([0, 1],
    [2, 1], [<font color=red>"white"</font>, <font color=red>"white2"</font>]);

aes.popFront;
assertEqual(aes.front.y, 1);
assertEqual(aes.front.colour, <font color=red>"white2"</font>);
assertEqual(<font color=red>""</font>, aes.front.label);

<font color=blue>auto</font> aes2 = <u>Aes</u>!(<font color=blue>double</font>[], <font color=red>"x"</font>, <font color=blue>double</font>[], <font color=red>"y"</font>)([0, 1], [2, 1]);
assertEqual(aes2.front.y, 2);
assertEqual(aes2.front.colour, <font color=red>"black"</font>);

<font color=blue>import</font> std.range : repeat;

<font color=blue>auto</font> xs = repeat(0);
<font color=blue>auto</font> aes3 = <u>Aes</u>!(<font color=blue>typeof</font>(xs), <font color=red>"x"</font>, <font color=blue>double</font>[], <font color=red>"y"</font>)(xs, [2, 1]);

assertEqual(aes3.front.x, 0);
aes3.popFront;
aes3.popFront;
assertEqual(aes3.empty, <font color=blue>true</font>);
</pre>
<br><br>
<dl><dt><big><a name="Aes.Types"></a>alias <u>Types</u> = staticMap!(extractType, fieldSpecs);
</big></dt>
<dd>The type of the tuple's components.<br><br>

</dd>
<dt><big><a name="Aes.fieldNames"></a>alias <u>fieldNames</u> = staticMap!(extractName, fieldSpecs);
</big></dt>
<dd>The names of the tuple's components. Unnamed fields have empty names.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>alias</font> Fields = Tuple!(<font color=blue>int</font>, <font color=red>"id"</font>, string, <font color=blue>float</font>);
<font color=blue>static</font> <font color=blue>assert</font>(Fields.<u>fieldNames</u> == TypeTuple!(<font color=red>"id"</font>, <font color=red>""</font>, <font color=red>""</font>));
</pre>
<br><br>

</dd>
<dt><big><a name="Aes.expand"></a>Types <u>expand</u>;
</big></dt>
<dd>Use  for a tuple  to <u>expand</u> it into its
 components. The result of  acts as if the tuple components
 were listed as a list of values. (Ordinarily, a  acts as a
 single value.)
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>auto</font> t = tuple(1, <font color=red>" hello "</font>, 2.3);
writeln(t);        <font color=green>// Tuple!(int, string, double)(1, " hello ", 2.3)
</font>writeln(t.<u>expand</u>); <font color=green>// 1 hello 2.3
</font></pre>
<br><br>

</dd>
<dt><big><a name="Aes.this"></a>this(Types <i>values</i>);
</big></dt>
<dd>Constructor taking one value for each field.<br><br>

</dd>
<dt><big><a name="Aes.this.2"></a>this(U, size_t n)(U[n] <i>values</i>) if (n == Types.length &amp;&amp; allSatisfy!(isBuildableFrom!U, Types));
</big></dt>
<dd>Constructor taking a compatible array.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>int</font>[2] ints;
Tuple!(<font color=blue>int</font>, <font color=blue>int</font>) t = ints;
</pre>
<br><br>

</dd>
<dt><big><a name="Aes.this.3"></a>this(U)(U <i>another</i>) if (areBuildCompatibleTuples!(typeof(this), U));
</big></dt>
<dd>Constructor taking a compatible tuple.<br><br>

</dd>
<dt><big><a name="Aes.popFront"></a>void <u>popFront</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Aes.empty"></a>@property bool <u>empty</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Aes.length"></a>size_t <u>length</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Aes.opEquals"></a>bool <u>opEquals</u>(R)(R <i>rhs</i>) if (areCompatibleTuples!(typeof(this), R, "=="));
<br>const bool <u>opEquals</u>(R)(R <i>rhs</i>) if (areCompatibleTuples!(typeof(this), R, "=="));
</big></dt>
<dd>Comparison for equality.<br><br>

</dd>
<dt><big><a name="Aes.opCmp"></a>int <u>opCmp</u>(R)(R <i>rhs</i>) if (areCompatibleTuples!(typeof(this), R, "&lt;"));
<br>const int <u>opCmp</u>(R)(R <i>rhs</i>) if (areCompatibleTuples!(typeof(this), R, "&lt;"));
</big></dt>
<dd>Comparison for ordering.<br><br>

</dd>
<dt><big><a name="Aes.opAssign"></a>void <u>opAssign</u>(R)(auto ref R <i>rhs</i>) if (areCompatibleTuples!(typeof(this), R, "="));
</big></dt>
<dd>Assignment from another tuple. Each element of the source must be
 implicitly assignable to the respective element of the target.<br><br>

</dd>
<dt><big><a name="Aes.slice"></a>@property ref @trusted Tuple!(sliceSpecs!(from, to)) <u>slice</u>(size_t from, size_t to)() if (from &lt;= to &amp;&amp; to &lt;= Types.length);
</big></dt>
<dd>Takes a <u>slice</u> of the tuple.
<br><br>
<b>Examples:</b><br>
<pre class="d_code">Tuple!(<font color=blue>int</font>, string, <font color=blue>float</font>, <font color=blue>double</font>) a;
a[1] = <font color=red>"abc"</font>;
a[2] = 4.5;
<font color=blue>auto</font> s = a.<u>slice</u>!(1, 3);
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(s) == Tuple!(string, <font color=blue>float</font>)));
<font color=blue>assert</font>(s[0] == <font color=red>"abc"</font> &amp;&amp; s[1] == 4.5);
</pre>
<br><br>

</dd>
<dt><big><a name="Aes.toHash"></a>const nothrow @trusted size_t <u>toHash</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="Aes.toString"></a>void <u>toString</u>(DG)(scope DG <i>sink</i>);
</big></dt>
<dd>Converts to string.<br><br>

</dd>
<dt><big><a name="Aes.toString.2"></a>string <u>toString</u>()();
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="group"></a>template <u>group</u>(Specs...)</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="NumericLabel"></a>struct <u>NumericLabel</u>(T) if (isInputRange!T);
</big></dt>
<dd><br><br>
<dl><dt><big><a name="NumericLabel.this"></a>this(T <i>range</i>);
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="NumericLabel.front"></a>@property auto <u>front</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="NumericLabel.popFront"></a>void <u>popFront</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="NumericLabel.empty"></a>@property bool <u>empty</u>();
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="NumericLabel.numeric"></a>@property bool <u>numeric</u>();
</big></dt>
<dd><br><br>
</dd>
</dl>
</dd>
<dt><big><a name="merge"></a>auto <u>merge</u>(T, U)(T <i>base</i>, U <i>other</i>);
</big></dt>
<dd>Merge two Aes structs
<br><br>
If it has similar named types, then it uses the second one.
<br><br>

Returns a new struct, with combined types.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.range : front;

<font color=blue>auto</font> xs = [<font color=red>"a"</font>, <font color=red>"b"</font>];
<font color=blue>auto</font> ys = [<font color=red>"c"</font>, <font color=red>"d"</font>];
<font color=blue>auto</font> labels = [<font color=red>"e"</font>, <font color=red>"f"</font>];
<font color=blue>auto</font> aes = Aes!(string[], <font color=red>"x"</font>, string[], <font color=red>"y"</font>, string[], <font color=red>"label"</font>)(xs, ys, labels);

<font color=blue>auto</font> nlAes = <u>merge</u>(aes, Aes!(NumericLabel!(string[]), <font color=red>"x"</font>,
    NumericLabel!(string[]), <font color=red>"y"</font>)(NumericLabel!(string[])(aes.x),
    NumericLabel!(string[])(aes.y)));

assertEqual(nlAes.x.front[0], 0);
assertEqual(nlAes.label.front, <font color=red>"e"</font>);
</pre>
<br><br>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
